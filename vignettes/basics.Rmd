---
title: "Basics"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{basics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(pcs.sim.pkg)

# create a data-generating process function to pass to create_dgp()
dgp_fun <- function(n, noise_level = 4) {
  X <- matrix(rnorm(n * 2), nrow=n)
  y <- cbind(1, X) %*% c(-8, 3, -1) + rnorm(n, sd = noise_level)
  return(list(X = X, y = y))
}

dgp <- create_dgp(dgp_fun, n = 200, noise_level = 1)

# create a method function to pass to create_method(); this this case, just get
# the p-values of the two predictors in the OLS fit of the data
method_fun <- function(X, y) {
  fit <- lm(y ~ X)
  return(list(
    "X1 p-val" = summary(fit)$coefficients["X1", "Pr(>|t|)"],
    "X2 p-val" = summary(fit)$coefficients["X2", "Pr(>|t|)"]
  ))
}

method <- create_method(method_fun)

eval_summary_fun <- function(results) {
  eval_out <- results %>%
    dplyr::group_by(dgp, method) %>%
    dplyr::summarise_all(~mean(.x < 0.05))
  return(eval_out)
}

eval_fun <- function(results) {
  eval_out <- results %>%
    dplyr::mutate_at(dplyr::vars(-dgp, -method), 
                     ~ifelse(.x < 0.05, "reject", "fail to reject"))
  return(eval_out)
}

summary_evaluator <- create_evaluator(eval_summary_fun)
evaluator <- create_evaluator(eval_fun)

# create the experiment and add the dgp and method
experiment <- create_experiment(n_reps = 1000, name = "base") %>%
  add_dgp(dgp) %>%
  add_method(method) %>%
  add_evaluator(summary_evaluator) %>%
  add_evaluator(evaluator)

future::plan(future::sequential)

# run sequentually
seq_start <- proc.time()
o1 <- experiment$run()
proc.time() - seq_start

eval_res <- experiment$evaluate(o1)

future::plan(future::multiprocess, workers=2)

# run in parallel with 2 processes
par_start <- proc.time()
o2 <- experiment$run()
proc.time() - par_start

future::plan(future::sequential)
```

# Inheriting traits from an existing Experiment

```{r inheritance}
child <- create_experiment(n_reps = 100, parent = experiment, name = "child")

names(experiment$get_children())
child$get_parent()$name

# no copy of dgps/method/evaluators is made when inheriting
data.table::address(experiment$get_dgps()[["dgp1"]]) ==
  data.table::address(child$get_dgps()[["dgp1"]]) # TRUE

# the child stays up-to-date with updates to its parent
dgp2 <- create_dgp(dgp_fun, n = 1000, noise_level = 2)
experiment$add_dgp(dgp2)

identical(experiment$get_dgps(), child$get_dgps()) # TRUE

# the child can have additional dgps (or methods/evaluators) beyond what the parent has
dgp3 <- create_dgp(dgp_fun, n = 500, noise_level = 3)
child$add_dgp(dgp2)

names(experiment$get_dgps())
names(child$get_dgps())

# the child experiment can override its parent's dgps without modifying the parent
dgp4 <- create_dgp(dgp_fun, n = 10000, noise_level = 10)
child$update_dgp(dgp4, "dgp1")

identical(experiment$get_dgps()[["dgp1"]], child$get_dgps()[["dgp1"]]) # FALSE
identical(dgp, experiment$get_dgps()[["dgp1"]]) # TRUE
identical(dgp4, child$get_dgps()[["dgp1"]]) # TRUE

# inheritance is nested...
grandchild <- create_experiment(n_reps = 100, parent = child, name = "grandchild")
names(grandchild$get_dgps())

# ...and allows for parallel branches
child2 <- create_experiment(n_reps = 100, parent = experiment, name = "child2")
names(experiment$get_children())
names(child2$get_dgps())
identical(child2$get_dgps()[['dgp1']], dgp)
```
