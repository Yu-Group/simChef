% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/visualizer-lib-utils.R
\name{plot_eval_summary}
\alias{plot_eval_summary}
\title{Developer function for plotting summary of evaluation results.}
\usage{
plot_eval_summary(
  fit_results,
  eval_tib = NULL,
  eval_id = NULL,
  eval_fun = paste0("summarize_", eval_id),
  vary_params = NULL,
  show = c("boxplot", "point", "line", "bar", "errorbar", "ribbon"),
  x_str = "auto",
  y_str = "auto",
  err_sd_str = "auto",
  color_str = "auto",
  linetype_str = "auto",
  facet_formula = NULL,
  facet_type = c("grid", "wrap"),
  plot_by = "auto",
  add_ggplot_layers = NULL,
  boxplot_args = NULL,
  point_args = NULL,
  line_args = NULL,
  bar_args = NULL,
  errorbar_args = NULL,
  ribbon_args = NULL,
  facet_args = NULL,
  interactive = FALSE,
  ...
)
}
\arguments{
\item{fit_results}{A tibble, as returned by the \code{fit} method.}

\item{eval_tib}{(Optional) \code{Tibble} (typically from the output of
\code{eval_summary_constructor}) containing the summarized evaluation
results to plot. If not provided, the evaluation results will be
automatically computed by calling \code{eval_fun()}. If the summarized
evaluation results have already been computed previously, \code{eval_tib}
should be specified to avoid duplicate computations.}

\item{eval_id}{Character string. ID used as the suffix for naming columns in
\code{eval_summary_constructor()}. Should be the same as the \code{eval_id}
argument in \code{eval_summary_constructor()}.}

\item{eval_fun}{Function used to compute evaluation results summary. This
function is only used (and required) if necessary results have not already
been computed in \code{eval_tib}.}

\item{vary_params}{A vector of parameter names that are varied across in the
\code{Experiment}.}

\item{show}{Character vector with elements being one of "boxplot", "point",
"line", "bar", "errorbar", "ribbon" indicating what plot layer(s) to
construct.}

\item{x_str}{(Optional) Name of column in \code{eval_tib} to plot on the
x-axis. Default "auto" chooses what to plot on the x-axis automatically.}

\item{y_str}{(Optional) Name of column in \code{eval_tib} to plot on the
y-axis if \code{show} is anything but "boxplot". Default "auto" chooses
what to plot on the y-axis automatically.}

\item{err_sd_str}{(Optional) Name of column in \code{eval_tib} containing the
standard deviations of \code{y_str}. Used for plotting the errorbar and
ribbon ggplot layers. Default "auto" chooses what column to use for the
standard deviations automatically.}

\item{color_str}{(Optional) Name of column in \code{eval_tib} to use for the
color and fill aesthetics when plotting. Default "auto" chooses what to
use for the color and fill aesthetics automatically. Use \code{NULL} to
avoid adding any color and fill aesthetic.}

\item{linetype_str}{(Optional) Name of column in \code{eval_tib} to use for
the linetype aesthetic when plotting. Used only when \code{show = "line"}.
Default "auto" chooses what to use for the linetype aesthetic
automatically. Use \code{NULL} to avoid adding any linetype aesthetic.}

\item{facet_formula}{(Optional) Formula for \code{ggplot2::facet_wrap()} or
\code{ggplot2::facet_grid()} if need be.}

\item{facet_type}{One of "grid" or "wrap" specifying whether to use
\code{ggplot2::facet_wrap()} or \code{ggplot2::facet_grid()} if need be.}

\item{plot_by}{(Optional) Name of column in \code{eval_tib} to use for
subsetting data and creating different plots for each unique value. Default
"auto" chooses what column to use for the subsetting automatically. Use
\code{NULL} to avoid creating multiple plots.}

\item{add_ggplot_layers}{List of additional layers to add to a ggplot object
via \code{+}.}

\item{boxplot_args}{(Optional) Additional arguments to pass into
\code{ggplot2::geom_boxplot()}.}

\item{point_args}{(Optional) Additional arguments to pass into
\code{ggplot2::geom_point()}.}

\item{line_args}{(Optional) Additional arguments to pass into
\code{ggplot2::geom_line()}.}

\item{bar_args}{(Optional) Additional arguments to pass into
\code{ggplot2::geom_bar()}.}

\item{errorbar_args}{(Optional) Additional arguments to pass into
\code{ggplot2::geom_errorbar()}.}

\item{ribbon_args}{(Optional) Additional arguments to pass into
\code{ggplot2::geom_ribbon()}.}

\item{facet_args}{(Optional) Additional arguments to pass into
\code{ggplot2::facet_grid()} or \code{ggplot2::facet_wrap()}.}

\item{interactive}{Logical. If \code{TRUE}, returns interactive \code{plotly}
plots. If \code{FALSE}, returns static \code{ggplot} plots.}

\item{...}{Additional arguments to pass to \code{eval_fun()}. This is only
used if necessary results have not already been computed in
\code{eval_tib}.}
}
\value{
If \code{interactive = TRUE}, returns a \code{plotly} object if
\code{plot_by} is \code{NULL} and a list of \code{plotly} objects if
\code{plot_by} is not \code{NULL}. If \code{interactive = FALSE}, returns
a \code{ggplot} object if \code{plot_by} is \code{NULL} and a list of
\code{ggplot} objects if \code{plot_by} is not \code{NULL}.
}
\description{
A helper function for developing new \code{Visualizer} plotting
functions that plot the summarized evaluation results as a boxplot,
scatter plot, line plot, or bar plot with or without 1 SD error
bars/ribbons. This function accepts either (1) a pre-computed tibble
containing the summarized evaluation results or (2) the Evaluator function
and its corresponding function arguments for computing the evaluation
results within this function call.
}
\examples{
# generate example fit results data
fit_results <- tibble::tibble(
  .rep = rep(1:2, times = 2),
  .dgp_name = c("DGP1", "DGP1", "DGP2", "DGP2"),
  .method_name = c("Method"),
  # true response
  y = lapply(1:4, FUN = function(x) rnorm(100)),
  # predicted response
  predictions = lapply(1:4, FUN = function(x) rnorm(100))
)

# generate example evaluation results data
eval_results <- list(
  `Prediction Errors` = summarize_pred_err(
    fit_results = fit_results, 
    truth_col = "y", 
    estimate_col = "predictions", 
    eval_id = "pred_err"
  )
)

# create plot using pre-computed evaluation results
plt <- plot_eval_summary(fit_results = fit_results, 
                         eval_tib = eval_results[["Prediction Errors"]],
                         eval_id = "pred_err",
                         show = c("point", "errorbar"),
                         facet_formula = ~ .metric)
# can customize plots using additional arguments or ggplot2::`+`
plt <- plot_eval_summary(fit_results = fit_results, 
                         eval_tib = eval_results[["Prediction Errors"]],
                         eval_id = "pred_err",
                         show = c("point", "errorbar"),
                         facet_formula = ~ .metric,
                         facet_type = "wrap",
                         errorbar_args = list(width = 0.5),
                         facet_args = list(scales = "free")) +
  ggplot2::labs(y = "Mean Prediction Error")
# can return interactive plotly plot
plt <- plot_eval_summary(fit_results = fit_results, 
                         eval_tib = eval_results[["Prediction Errors"]],
                         eval_id = "pred_err",
                         show = c("point", "errorbar"),
                         facet_formula = ~ .metric,
                         interactive = TRUE)

# create plot without pre-computing evaluation results; instead, need to 
# pass in summarize_* function and its arguments
plt <- plot_eval_summary(fit_results = fit_results,
                         eval_id = "pred_err",
                         eval_fun = "summarize_pred_err",
                         truth_col = "y", 
                         estimate_col = "predictions",
                         show = c("point", "errorbar"),
                         facet_formula = ~ .metric)

}
