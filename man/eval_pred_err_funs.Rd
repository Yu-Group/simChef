% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evaluator-lib-prediction.R
\name{eval_pred_err_funs}
\alias{eval_pred_err_funs}
\alias{eval_pred_err}
\alias{summarize_pred_err}
\title{Evaluate and/or summarize prediction errors.}
\usage{
eval_pred_err(
  fit_results,
  vary_params = NULL,
  nested_data = NULL,
  truth_col,
  estimate_col,
  prob_cols = NULL,
  group_cols = NULL,
  metrics = NULL,
  options = list(),
  na_rm = FALSE
)

summarize_pred_err(
  fit_results,
  vary_params = NULL,
  nested_data = NULL,
  truth_col,
  estimate_col,
  prob_cols = NULL,
  group_cols = NULL,
  metrics = NULL,
  options = list(),
  na_rm = FALSE,
  summary_funs = c("mean", "median", "min", "max", "sd", "raw"),
  custom_summary_funs = NULL,
  eval_id = "pred_err"
)
}
\arguments{
\item{fit_results}{A tibble, as returned by the \code{fit} method.}

\item{vary_params}{A vector of parameter names that are varied across in the
\code{Experiment}.}

\item{nested_data}{(Optional) Character string. If specified, should be the
name of the column in \code{fit_results} containing columns that must be
unnested before evaluating results. Default is \code{NULL}, meaning no
columns in \code{fit_results} need to be unnested prior to computation.}

\item{truth_col}{A character string identifying the column with the true
responses. The column should be numeric for a regression problem and a
factor for a classification problem.}

\item{estimate_col}{A character string identifying the column with the
estimated or predicted responses. The column should be numeric for a
regression problem and a factor (with the predicted classes) for a
classification problem.}

\item{prob_cols}{A character string or vector identifying the column(s)
containing class probabilities. If the \code{truth_col} column is binary,
only 1 column name should be provided. Otherwise, the length of the
\code{prob_cols} should be equal to the number of factor levels of
the \code{truth_col} column. This argument is not used when evaluating
numeric metrics.}

\item{group_cols}{(Optional) A character string or vector identifying the
column(s) to group observations by before evaluating prediction errors.
This is useful for assessing within-group prediction errors.}

\item{metrics}{A \code{metric_set} object indicating the metrics to evaluate.
See \code{\link[yardstick:metric_set]{yardstick::metric_set()}} for more details. Default \code{NULL} will
use the default metrics in \code{\link[yardstick:metrics]{yardstick::metrics()}}.}

\item{options}{A list of named options to pass to \code{pROC::roc()} such as
\code{smooth}. These options should not include \code{response},
\code{predictor}, \code{levels}, \code{quiet}, or \code{direction}. This
argument is only used when computing the ROC and is ignored otherwise.}

\item{na_rm}{A \code{logical} value indicating whether \code{NA} values
should be stripped before the computation proceeds.}

\item{summary_funs}{Character vector specifying how to summarize
evaluation metrics. Must choose from a built-in library of summary
functions - elements of the vector must be one of "mean", "median",
"min", "max", "sd", "raw".}

\item{custom_summary_funs}{Named list of custom functions to summarize
results. Names in the list should correspond to the name of the summary
function. Values in the list should be a function that takes in one
argument, that being the values of the evaluated metrics.}

\item{eval_id}{Character string. ID to be used as a suffix when naming result
columns. Default \code{NULL} does not add any ID to the column names.}
}
\value{
The output of \code{eval_pred_err()} is a \code{tibble} with the following
columns:
\describe{
\item{.rep}{Replicate ID.}
\item{.dgp_name}{Name of DGP.}
\item{.method_name}{Name of Method.}
\item{.metric}{Name of the evaluation metric.}
\item{.estimate}{Value of the evaluation metric.}
}
as well as any columns specified by \code{group_cols} and \code{vary_params}.

The output of \code{summarize_pred_err()} is a grouped \code{tibble}
containing both identifying information and the prediction error results
aggregated over experimental replicates. Specifically, the identifier columns
include \code{.dgp_name}, \code{.method_name}, any columns specified by
\code{group_cols} and \code{vary_params}, and  \code{.metric}. In addition,
there are results columns corresponding to the requested statistics in
\code{summary_funs} and \code{custom_summary_funs}. These columns end in the
suffix specified by \code{eval_id}.
}
\description{
Evaluate various prediction error metrics, given the true
responses and the predicted (or estimated) responses.
\code{eval_pred_err()} evaluates the various prediction error metrics for
each experimental replicate separately. \code{summarize_pred_err()}
summarizes the various prediction error metrics across experimental
replicates.
}
\examples{
############################
#### Regression Problem ####
############################

# generate example fit_results data for a regression problem
fit_results <- tibble::tibble(
  .rep = rep(1:2, times = 2),
  .dgp_name = c("DGP1", "DGP1", "DGP2", "DGP2"),
  .method_name = c("Method"),
  # true response
  y = lapply(1:4, FUN = function(x) rnorm(100)),
  # predicted response
  predictions = lapply(1:4, FUN = function(x) rnorm(100)),
  group = lapply(1:4, FUN = function(x) rep(c("a", "b"), length.out = 100))
)

# evaluate prediction error (using all default metrics) for each replicate
eval_results <- eval_pred_err(fit_results,
                              truth_col = "y",
                              estimate_col = "predictions")
# summarize prediction error (using all default metric) across replicates
eval_results_summary <- summarize_pred_err(fit_results,
                                           truth_col = "y",
                                           estimate_col = "predictions")

# evaluate/summarize prediction error within subgroups
eval_results <- eval_pred_err(fit_results,
                              truth_col = "y",
                              estimate_col = "predictions",
                              group_cols = "group")
eval_results_summary <- summarize_pred_err(fit_results,
                                           truth_col = "y",
                                           estimate_col = "predictions",
                                           group_cols = "group")

# evaluate/summarize prediction errors using specific yardstick metrics
metrics <- yardstick::metric_set(yardstick::rmse, yardstick::rsq)
eval_results <- eval_pred_err(fit_results,
                              truth_col = "y",
                              estimate_col = "predictions",
                              metrics = metrics)
eval_results_summary <- summarize_pred_err(fit_results,
                                           truth_col = "y",
                                           estimate_col = "predictions",
                                           metrics = metrics)

# summarize prediction errors using specific summary metric
range_fun <- function(x) return(max(x) - min(x))
eval_results_summary <- summarize_pred_err(
  fit_results,
  truth_col = "y",
  estimate_col = "predictions",
  custom_summary_funs = list(range_pred_err = range_fun)
)

#######################################
#### Binary Classification Problem ####
#######################################
# generate example fit_results data for a binary classification problem
fit_results <- tibble::tibble(
  .rep = rep(1:2, times = 2),
  .dgp_name = c("DGP1", "DGP1", "DGP2", "DGP2"),
  .method_name = c("Method"),
  # true response
  y = lapply(1:4,
             FUN = function(x) {
               as.factor(sample(0:1, size = 100, replace = TRUE))
             }),
  # predicted class probabilities
  class_probs = lapply(1:4, FUN = function(x) runif(n = 100, min = 0, max = 1)),
  # predicted class responses
  predictions = lapply(class_probs,
                       FUN = function(x) as.factor(ifelse(x > 0.5, 1, 0)))
)

# evaluate prediction error (using all default metrics) for each replicate
eval_results <- eval_pred_err(fit_results,
                              truth_col = "y",
                              estimate_col = "predictions",
                              prob_cols = "class_probs")
# summarize prediction error (using all default metric) across replicates
eval_results_summary <- summarize_pred_err(fit_results,
                                           truth_col = "y",
                                           estimate_col = "predictions",
                                           prob_cols = "class_probs")

# can also evaluate results using only class predictions (without class probs.)
eval_results <- eval_pred_err(fit_results,
                              truth_col = "y",
                              estimate_col = "predictions")
eval_results_summary <- summarize_pred_err(fit_results,
                                           truth_col = "y",
                                           estimate_col = "predictions")

############################################
#### Multi-class Classification Problem ####
############################################
# generate example fit_results data for a multi-class classification problem
fit_results <- tibble::tibble(
  .rep = rep(1:2, times = 2),
  .dgp_name = c("DGP1", "DGP1", "DGP2", "DGP2"),
  .method_name = c("Method"),
  # true response
  y = lapply(1:4,
             FUN = function(x) {
               as.factor(sample(c("a", "b", "c"), size = 100, replace = TRUE))
             }),
  # predicted class probabilities
  class_probs = lapply(1:4,
                       FUN = function(x) {
                         tibble::tibble(a = runif(n = 100, min = 0, max = 0.5),
                                        b = runif(n = 100, min = 0, max = 0.5),
                                        c = 1 - a - b)
                       }),
  # predicted class responses
  predictions = lapply(class_probs,
                       FUN = function(x) {
                         yhat <- apply(x, 1,
                                       FUN = function(xi) names(which.max(xi)))
                         return(as.factor(yhat))
                       })
)

# evaluate prediction error (using all default metrics) for each replicate
eval_results <- eval_pred_err(fit_results,
                              truth_col = "y",
                              estimate_col = "predictions",
                              prob_cols = c("a", "b", "c"),
                              nested_data = "class_probs")
#' summarize prediction error (using all default metric) across replicates
eval_results_summary <- summarize_pred_err(fit_results,
                                           truth_col = "y",
                                           estimate_col = "predictions",
                                           prob_cols = c("a", "b", "c"),
                                           nested_data = "class_probs")

# can also evaluate results using only class predictions (without class probs.)
eval_results <- eval_pred_err(fit_results,
                              truth_col = "y",
                              estimate_col = "predictions")
eval_results_summary <- summarize_pred_err(fit_results,
                                           truth_col = "y",
                                           estimate_col = "predictions")

}
\seealso{
Other prediction_error_funs: 
\code{\link{eval_pred_curve_funs}},
\code{\link{plot_pred_curve}()},
\code{\link{plot_pred_err}()}
}
\concept{prediction_error_funs}
