% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dgp-lib.R
\name{linear_gaussian_dgp}
\alias{linear_gaussian_dgp}
\title{Generate independent Gaussian covariates and linear response data.}
\usage{
linear_gaussian_dgp(
  n,
  p_obs = 0,
  p_unobs = 0,
  s_obs = p_obs,
  s_unobs = p_unobs,
  betas = NULL,
  betas_unobs = NULL,
  intercept = 0,
  err = NULL,
  data_split = FALSE,
  train_prop = 0.5,
  return_values = c("X", "y", "support"),
  ...
)
}
\arguments{
\item{n}{Number of samples.}

\item{p_obs}{Number of observed features.}

\item{p_unobs}{Number of unobserved (omitted) features.}

\item{s_obs}{Sparsity level of observed features. Coefficients corresponding
to features after the \code{s_obs} position (i.e., positions i =
\code{s_obs} + 1, ..., \code{p_obs}) are set to 0.}

\item{s_unobs}{Sparsity level of unobserved (omitted) features. Coefficients
corresponding to features after the \code{s_unobs} position (i.e.,
positions i = \code{s_unobs} + 1, ..., \code{p_unobs}) are set to 0.}

\item{betas}{Coefficient vector for observed design matrix. If a scalar is provided, the coefficient vector is constant. If \code{NULL} (default), entries in the coefficient vector are drawn iid from N(0, \code{betas_sd}^2). Can also be a function that generates the coefficient vector; see \code{generate_coef()}.}

\item{betas_unobs}{Coefficient vector for unobserved design matrix. If a scalar is provided, the coefficient vector is constant. If \code{NULL} (default), entries in the coefficient vector are drawn iid from N(0, \code{betas_unobs_sd}^2). Can also be a function that generates the coefficient vector; see \code{generate_coef()}.}

\item{intercept}{Scalar intercept term.}

\item{err}{Function from which to generate simulated error vector. Default is
\code{NULL} which adds no error to the DGP.}

\item{data_split}{Logical; if \code{TRUE}, splits data into training and test
sets according to \code{train_prop}.}

\item{train_prop}{Proportion of data in training set if \code{data_split =
TRUE}.}

\item{return_values}{Character vector indicating what objects to return in
list. Elements in vector must be one of "X", "y", "support".}

\item{...}{Additional arguments to pass to functions that generate X, U, y, betas, betas_unobs, and err. If the argument doesn't exist in one of the functions it is ignored. If two or more of the functions have an argument of the same name but with different values, then use one of the following prefixes in front of the argument name (passed via \code{...}) to differentiate it: .X_, .U_, .y_, .betas_, .betas_unobs_, or .err_. For additional details, see \code{generate_X_gaussian()}, \code{generate_y_linear()}, \code{generate_coef()}, and \code{generate_errors()}}
}
\value{
A list of the named objects that were requested in
\code{return_values}. See brief descriptions below.
\describe{
\item{X}{A \code{data.frame}.}
\item{y}{A response vector of length \code{nrow(X)}.}
\item{support}{A vector of feature indices indicating all features used in
the true support of the DGP.}
}
Note that if \code{data_split = TRUE} and "X", "y"
are in \code{return_values}, then the returned list also contains slots for
"Xtest" and "ytest".
}
\description{
Generate independent normally-distributed covariates (including
potentially omitted variables) and linear response data with a specified
error distribution.
}
\details{
Data is generated via: \deqn{y = intercept + betas \%\emph{\% X +
betas_unobs \%}\% U + err(...),} where X, U are standard Gaussian random
matrices and the true underlying support of this data is the first s_obs and
s_unobs features in X and U respectively.
}
\examples{
# generate data from: y = betas_1 * x_1 + betas_2 * x_2 + N(0, 0.5), where
# betas_1, betas_2 ~ N(0, 1) and X ~ N(0, I_10)
sim_data <- linear_gaussian_dgp(n = 100, p_obs = 10, s_obs = 2, betas_sd = 1,
                                err = rnorm, sd = .5)

# generate data from y = betas \%*\% X - u_1 + t(df = 1), where
# betas ~ N(0, .5), betas_unobs = [-1, 0], X ~ N(0, I_10), U ~ N(0, I_2)
sim_data <- linear_gaussian_dgp(n = 100, p_obs = 10, p_unobs = 2,
                                betas_sd = .5, betas_unobs = c(-1, 0),
                                err = rt, df = 1)

}
