% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dgp-lib.R
\name{xy_dgp_wrapper}
\alias{xy_dgp_wrapper}
\title{General DGP wrapper function to generate X and y data.}
\usage{
xy_dgp_wrapper(
  x_fun,
  y_fun,
  err_fun,
  data_split = FALSE,
  train_prop = 0.5,
  return_values = c("X", "y", "support"),
  ...
)
}
\arguments{
\item{x_fun}{Function to generate X data.}

\item{y_fun}{Function to generate y data.}

\item{err_fun}{Function to generate error/noise data.}

\item{data_split}{Logical; if \code{TRUE}, splits data into training and test
sets according to \code{train_prop}.}

\item{train_prop}{Proportion of data in training set if
\code{data_split = TRUE}.}

\item{return_values}{Character vector indicating what objects to return in
list. Elements in vector must be one of "X", "y", "support".}

\item{...}{Additional arguments to pass to \code{x_fun}, \code{y_fun},
and \code{err_fun}. If argument does not exist in \code{x_fun},
\code{y_fun}, or \code{err_fun}, argument is ignored.}
}
\value{
A list of the named objects that were requested in
\code{return_values}. Note that if \code{data_split = TRUE} and "X", "y"
are in \code{return_values}, then the returned list also contains slots for
"Xtest" and "ytest".
}
\description{
A general DGP wrapper function that generates X and y data for
any supervised learning DGP, provided the functions for simulating X, y,
and the additive error term.
}
\details{
TODO: explain how to write x_fun, y_fun, err_fun. Required args +
optional args + other caveats.
Model: y = y_fun(X) + err_fun(X, y_fun(X)), where X = x_fun(...)
}
\examples{
data_out <- xy_dgp_wrapper(x_fun = MASS::mvrnorm, y_fun = generate_y_linear,
                           err_fun = rnorm, data_split = TRUE,
                           # dgp arguments
                           n = 100, 
                           # arguments specifically for x_fun
                           .x_mu = rep(0, 10), .x_Sigma = diag(10),
                           # arguments specifically for y_fun
                           .y_betas = rnorm(10), .y_return_support = TRUE,
                           # arguments specifically for err_fun
                           .err_sd = 1)
data_out <- xy_dgp_wrapper(x_fun = MASS::mvrnorm, y_fun = generate_y_linear,
                           err_fun = rnorm, data_split = TRUE,
                           # dgp arguments
                           n = 100, 
                           # arguments specifically for x_fun
                           mu = rep(0, 10), Sigma = diag(10),
                           # arguments specifically for y_fun
                           betas = rnorm(10), return_support = TRUE,
                           # arguments specifically for err_fun
                           sd = 1)

}
