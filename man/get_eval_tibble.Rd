% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/visualizer-lib-utils.R
\name{get_eval_tibble}
\alias{get_eval_tibble}
\title{Get the summarized evaluation results tibble for plotting.}
\usage{
get_eval_tibble(
  fit_results,
  eval_tib = NULL,
  eval_id = NULL,
  eval_fun = paste0("summarize_", eval_id),
  vary_params = NULL,
  show,
  y_str = NULL,
  ...
)
}
\arguments{
\item{fit_results}{A tibble, as returned by the \code{fit} method.}

\item{eval_tib}{(Optional) \code{Tibble} (typically from the output of
\code{eval_summary_constructor}) containing the summarized evaluation
results to plot. If not provided, the evaluation results will be
automatically computed by calling \code{eval_fun()}. If the summarized
evaluation results have already been computed previously, \code{eval_tib}
should be specified to avoid duplicate computations.}

\item{eval_id}{Character string. ID used as the suffix for naming columns in
\code{eval_summary_constructor()}. Should be the same as the \code{eval_id}
argument in \code{eval_summary_constructor()}.}

\item{eval_fun}{Function used to compute evaluation results summary. This
function is only used (and required) if necessary results have not already
been computed in \code{eval_tib}.}

\item{vary_params}{A vector of parameter names that are varied across in the
\code{Experiment}.}

\item{show}{Character vector with elements being one of "boxplot", "point",
"line", "bar", "errorbar", "ribbon" indicating what plot layer(s) to
construct.}

\item{y_str}{(Optional) Name of column in \code{eval_tib} to plot on the
y-axis if \code{show} is anything but "boxplot". Default "auto" chooses
what to plot on the y-axis automatically.}

\item{...}{Additional arguments to pass to \code{eval_fun()}. This is only
used if necessary results have not already been computed in
\code{eval_tib}.}
}
\value{
A \code{tibble} with the summarized evaluation results.
}
\description{
Helper function to get the summarized evaluation results
\code{tibble} for plotting. This function will compute the summarized
evaluation results if they have not been computed previously. Otherwise,
it will read in the previously computed results and compute and append any
new results necessary to construct the specified plot.
}
\examples{
# generate example fit results data
fit_results <- tibble::tibble(
  .rep = rep(1:2, times = 2),
  .dgp_name = c("DGP1", "DGP1", "DGP2", "DGP2"),
  .method_name = c("Method"),
  # true response
  y = lapply(1:4, FUN = function(x) rnorm(100)),
  # predicted response
  predictions = lapply(1:4, FUN = function(x) rnorm(100))
)

# compute (from scratch) the evaluation results that are necessary for plotting
eval_tib <- get_eval_tibble(fit_results = fit_results, 
                            eval_tib = NULL,
                            eval_id = "pred_err",
                            eval_fun = "summarize_pred_err", 
                            show = c("point", "errorbar"),
                            y_str = NULL,  # or equivalently, "mean_pred_err"
                            # arguments to pass to `eval_fun`
                            truth_col = "y",
                            estimate_col = "predictions")
# this is equivalent to:
eval_tib2 <- summarize_pred_err(
  fit_results = fit_results, 
  truth_col = "y",
  estimate_col = "predictions",
  summary_funs = c("mean", "sd")
)
all.equal(eval_tib, eval_tib2)

# read in pre-computed evaluation results since it has everything needed for plotting
eval_tib <- get_eval_tibble(fit_results = fit_results,
                            eval_tib = eval_tib, 
                            eval_id = "pred_err",
                            eval_fun = "summarize_pred_err", 
                            show = c("point", "errorbar"),
                            y_str = NULL)  # or equivalently, "mean_pred_err"
all.equal(eval_tib, eval_tib2)

# if columns that are needed for plotting are missing in `eval_tib`, then
# `get_eval_tibble` will call the `eval_fun` and compute the necessary results
eval_tib <- get_eval_tibble(fit_results = fit_results, 
                            eval_tib = eval_tib \%>\% dplyr::select(-mean_pred_err),
                            eval_id = "pred_err",
                            eval_fun = "summarize_pred_err", 
                            show = c("point", "errorbar"),
                            y_str = NULL,  # or equivalently, "mean_pred_err"
                            # arguments to pass to `eval_fun`
                            truth_col = "y",
                            estimate_col = "predictions")
all.equal(eval_tib, eval_tib2)
  
}
