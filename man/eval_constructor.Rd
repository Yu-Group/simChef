% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evaluator-lib-utils.R
\name{eval_constructor}
\alias{eval_constructor}
\title{Developer function to construct basic Evaluator.}
\usage{
eval_constructor(
  fit_results,
  vary_params = NULL,
  fun,
  nested_cols = NULL,
  ...,
  group_cols = NULL,
  fun_options = NULL,
  na_rm = FALSE
)
}
\arguments{
\item{fit_results}{A tibble, as returned by \code{fit_experiment()}.}

\item{vary_params}{A vector of parameter names that are varied across in the
\code{Experiment}.}

\item{fun}{Function to compute for each row in \code{fit_results}. This
function can take in the following optional arguments: (1) \code{data} =
\code{fit_results[i, ]}; (2) na_rm; (3) arguments specified via \code{...}
and \code{fun_options}.}

\item{nested_cols}{(Optional) A character string or vector specifying the
name of the column(s) in \code{fit_results} that need to be
unnested before evaluating results. Default is \code{NULL}, meaning no
columns in \code{fit_results} need to be unnested prior to computation.}

\item{...}{Named arguments, containing names of columns to pass to
\code{fun}.}

\item{group_cols}{(Optional) A character string or vector specifying the
column(s) to group rows by before evaluating metrics.
This is useful for assessing within-group metrics.}

\item{fun_options}{Named list of additional arguments to pass to \code{fun}.}

\item{na_rm}{A \code{logical} value indicating whether \code{NA} values
should be stripped before the computation proceeds.}
}
\description{
Helper function for developing a new \code{Evaluator}
that evaluates some function (e.g., metric) for each row in
\code{fit_results}.
}
\examples{
# generate example fit_results data for a regression problem
fit_results <- tibble::tibble(
  .rep = rep(1:2, times = 2),
  .dgp_name = c("DGP1", "DGP1", "DGP2", "DGP2"),
  .method_name = c("Method"),
  # true response
  y = lapply(1:4, FUN = function(x) rnorm(100)),
  # predicted response
  predictions = lapply(1:4, FUN = function(x) rnorm(100))
)

# evaluate root mean squared error for each row in fit_results
rmse_fun <- function(data, truth_col, estimate_col, na_rm = TRUE) {
  yardstick::rmse_vec(
    data[[truth_col]], data[[estimate_col]], na_rm = na_rm
  )
}
eval_results <- eval_constructor(
  fit_results = fit_results,
  fun = rmse_fun,
  truth_col = "y",
  estimate_col = "predictions"
) \%>\%
  tidyr::unnest(.eval_result)

}
